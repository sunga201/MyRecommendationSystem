import timeimport numpy as npclass User_Mode:    def __init__(self, loaded, calculated, tf_idf, rec):        self.rec_list=[]        self.loaded=loaded        self.calculated=calculated        self.rec=rec # 학습, 평점 행렬과 관련된 메소드들이 모여있는 클래스        self.pred_matrix, self.matrix, self.items, self.users=self.rec.get_matrices()        self.idx_to_name=list(self.items.keys()) # 인덱스를 통해 음악 이름을 찾는다.        # pred_matrix : 예측 평점 행렬, matrix : 기존 평점 행렬, items : 아이템-인덱스 딕셔너리, users : 사용자-인덱스 딕셔너리        self.num=0        self.recommended=False        start=time.time()        self.tf_idf=tf_idf        self.show_user_menu()    def show_user_menu(self):        if self.loaded == 0 and self.calculated == 0:            print("예측 평점 행렬이 존재하지 않습니다. 관리자 모드를 통해 예측 평점 행렬을 구해주세요.\n")            return        self.userID = input("Enter your ID : ")        while self.userID not in self.users.keys():            print('아이디를 확인해주세요.')            self.userID = input("아이디를 입력해주세요. : ") # 사용자 ID 저장        self.user_idx=self.users[self.userID] # 예측 평점 행렬에서 사용자의 인덱스 저장        # 예측 평점 행렬에서 해당 유저가 가지는 각 상품들의 평점을 test_list에 저장한다.        # 소숫점 둘째 자리에서 반올림.        while True:            print("\n", '-' * 5, 'user mode', '-' * 5)            print('1. 추천 목록 출력')            print('2. 추천 목록에서 특정 항목 제거하기')            print('3. 인기곡으로부터 추천받기')            print('4. 돌아가기')            select = input('select : ')            if select == '1':                self.recommend_item()            elif select == '2':                self.delete_item()            elif select=='3':                self.show_pop_ranking()            elif select == '4':                self.rec.save_matrix('rating_matrix.npy')                print()                return            else:                print("Please enter a valid number. (1-3)\n")    def get_updated_rating_list(self):        pred_matrix, _, _, _ = self.rec.get_matrices()        return list(map(lambda a: round(a, 3), pred_matrix[:, self.user_idx]))    # recommend_item() : recommend k items for user.    def recommend_item(self):        self.recommended=True        self.num = int(input("표시할 항목 수를 입력해주세요. : "))        self.show_recommand_music()    def show_recommand_music(self):        nonzero_row, nonzero_col = self.rec.get_nonzero(self.rec.get_matrix())  # 기존에 존재하던 평점들의 인덱스를 저장한다.        item_idx = []        self.rec_list=[]        for i in range(len(nonzero_col)):            if nonzero_col[i] == self.user_idx:  # 해당 유저가 평가한 상품들을 item_idx 리스트에 저장한다.                row = nonzero_row[i]                item_idx.append(row)        rating_list=self.get_updated_rating_list()        for i in range(len(rating_list)):            self.rec_list.append([self.idx_to_name[i], rating_list[i]])        for i in item_idx:            self.rec_list[i][1] = 0  # 기존에 있었던 평점은 0으로 취급하여 추천 목록에 들어가지 않게 한다.        self.rec_list.sort(key=lambda x: x[1], reverse=True) # self.rec_list는 추후에 추천 목록에서 아이템을 지울 때도 사용한다.        print('-'*40, '추천 목록', '-'*40)        print('-'*10, 'item', '-'*4, 'expected rate', '-'*25, 'keyword',  '-'*21)        for i in range(self.num):            print('%-2d.  |  %s  |   %.3lf    |    ' % (i + 1, self.rec_list[i][0], self.rec_list[i][1]), end=' ')            print(self.tf_idf.get_tfidf(self.rec_list[i][0], 5))    #get_similar_list :    def get_similar_list(self, compare_item):        compare_ID, compare_rate = compare_item        sim = self.cal_item_similarity(compare_ID)  # 인덱스가 remove_ID인 상품과 다른 상품간의 similarity 값을 구하여 리스트로 저장한다.        #tmp_list = [(compare_ID, -1)] # 어떤 상품과 관련된 유사도인지를 알려준다.        tmp_list=[]        for similar_item in sim:            item_ID, sim_rate = similar_item            item_idx = self.items[item_ID]            if sim_rate < 0.2: break  # 유사도 0.2 이하인 상품들은 무시한다.            tmp_list.append((item_idx, sim_rate))        return tmp_list    #change_prediction_rating() : 예측 평점 행렬에서 특정 예측 평점을 올리거나 내려준다.    def change_prediction_rating(self, remove_idx, similar_list, removed_list=[], inc=True):        '''        :param idx:        :param remove_idx:        :param similar_list: 유사도 행렬        :param removed_list:        :param inc: True이면 평점을 올리고, False이면 평점을 내린다.        :return:        '''        tmp_rate_list = []        if inc : sign=1        else : sign=-1 # 평점을 올릴지 내릴지 결정        rating_list=self.get_updated_rating_list()        for item_s in similar_list:            '''            item_s는 투플 형태이며, (아이템 인덱스, 유사도) 형태이다.            item_s_rate : similar list에 있는 아이템의 평점 행렬 상에서의 인덱스            item_s_sim : similar list에 있는 아이템과 제거 대상 상품과의 유사도            '''            item_s_rate = rating_list[item_s[0]]            item_s_sim = item_s[1]            if [self.idx_to_name[item_s[0]], item_s_rate] in removed_list:                continue            chg_rating = round(item_s_rate * (1 +  sign * item_s_sim / 4), 3)  # 유사도에 비례해서 평점을 올리거나 내려준다.            self.rec.change_rating(item_s[0], self.user_idx, chg_rating)            tmp_rate_list.append(chg_rating)        return tmp_rate_list    def input_process(self, string, num, list):        while True:            chk=0            num_list = input(string).replace(',', ' ').split()  # 사용자로부터 인덱스 목록을 받는다.            if num_list[0]=='-1' : return [-1]            print()  # 한줄 띄우기            idx_list = []            for idx_str in num_list:                if idx_str == -1: return                try:                    idx = int(idx_str) - 1                    if idx < 0 or idx > num - 1: # 입력값이 범위를 넘어가면 에러 throw                        raise ValueError                except ValueError or AttributeError:                    print('올바른 숫자를 입력해주세요.')                    chk = 1                    break                idx_list.append(list[idx])            if not chk: break        return idx_list    def delete_item(self):        if not self.recommended:            self.num = int(input("Enter number of items : "))        self.show_recommand_music()        removed_list=self.input_process('\n추천목록에서 지우고 싶은 음악의 번호를 입력해주세요. (메뉴로 돌아가시려면 -1을 입력해주세요.): ',                                        self.num,                                        self.rec_list)        if removed_list[0]==-1 : return # 사용자가 -1을 입력하면 메뉴로 돌아간다.        similar_list=[]        decrease_rate = []        rating_list=self.get_updated_rating_list()        i = 0        for remove_item in removed_list:            similar_list.append(self.get_similar_list(remove_item))            remove_idx=self.items[remove_item[0]]            decrease_rate.append(self.change_prediction_rating(remove_idx, similar_list[i], removed_list, inc=False)) # inc : 평점을 올리려면 True, 아니면 False            self.rec.change_rating(remove_idx, self.user_idx, 1)  # 추천 목록에서 지울 항목은 평점 1로 변경            i+=1        print('-'*10, '아래의 음악들이 추천 목록에서 제외되었습니다.', '-'*10)        for item_r in removed_list:            print('- ', item_r[0])            self.rec.change_original_matrix(self.items[item_r[0]], self.user_idx, 0) # 사용자가 선호하지 않는 항목을 1점으로 설정한다. 이 변경 정보는 파일로 저장된다.        print('-'*10, '유사한 음악들의 추천도가 내려갔습니다.', '-'*10)        for i in range(len(removed_list)):            j = 0            isShowed = False            for item_s in similar_list[i]:                item_s_rate = rating_list[item_s[0]]                if item_s_rate>5 : break # 평점이 5점이 넘어간다는 것은 예측 평점이 아닌 기존에 주어진 평점이라는 뜻임. -> 평점을 내려주지 않아도 됨.                if [self.idx_to_name[item_s[0]], item_s_rate] in removed_list: # 평점을 내리려는 항목이 추천 목록에서 빠질 예정인 경우                    continue                if isShowed:                    print('                         ',                          ' 연관된 음악 : ', self.idx_to_name[item_s[0]],                          ' 유사도 : ', round((item_s[1] * 100), 1), '%',                          ' 예측 평점 변화 : ', item_s_rate,                          ' -> ', max(1, decrease_rate[i][j]))  # self.test_list : 특정 사용자가 가지는 예측 평점들의 모임                else:                    print('삭제된 음악 : ', removed_list[i][0],                        ' 연관된 음악 : ', self.idx_to_name[item_s[0]],                        ' 유사도 : ', round((item_s[1] * 100), 1), '%',                        ' 예측 평점 변화 : ', item_s_rate,                        ' -> ', max(1, decrease_rate[i][j])) #self.test_list : 특정 사용자가 가지는 예측 평점들의 모임                    isShowed=True                j+=1        self.rec.save_matrix('rating_matrix.npy') # 예측 평점 변경사항을 저장 파일에 반영한다.    def get_cosine_similarity(self, a, b):  # a와 b에는 평점 행렬에서 각 아이템 a와 b가 받은 평점들을 가진 리스트가 들어온다.        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))    #매개변수 item과 다른 모든 음악들간의 cosine similarity를 구하고, 이를 평점에 대해 내림차순으로 정렬하여 리턴한다.    def cal_item_similarity(self, item):        tmp_list=[]        idx=self.items[item]        for i in range(len(self.items)):            if idx == i: break            sim = self.get_cosine_similarity(self.matrix[i, :], self.matrix[idx, :])            tmp_list.append((self.idx_to_name[i], sim))        tmp_list.sort(key=lambda x: x[1], reverse=True)        return tmp_list            def show_pop_ranking(self): # 보편적으로 인기있는 항목들의 순위를 보여준다.        show_num=10 # 인기 차트 목록 갯수        rate_ranking=[]        item_list=list(self.items.keys())        for idx in range(len(self.items)):            item_ID=item_list[idx]            rate_ranking.append((item_ID, np.mean(self.matrix[idx, self.matrix[idx, :].nonzero()])))        rate_ranking.sort(key=lambda x : x[1], reverse=True)        print('-'*40, '인기 차트', '-'*40)        print(' '*38, '-------ID-------')        i=1        for item in rate_ranking[:10]: #상위 10개를 보여준다.            print(' '*33, '%-2d.  |  %s  |' % (i, item[0]))            i+=1        print(' ' * 38, '----------------')        print('-'*90)        self.get_preference_rate(rate_ranking[:show_num])    def get_preference_rate(self, list):        prefer_list=self.input_process('\n마음에 드는 곡이 있으신가요? (없으면 -1을 입력해주세요.): ',                                       len(list), list)        if prefer_list[0]==-1 :            return #사용자가 -1을 입력하면 메뉴로 돌아간다.        rating_list=[]        print('이런 곡들도 들어보세요!')        for prefer_item in prefer_list:            recommend_list = self.get_similar_list(prefer_item)            prev_rating_list=[]            increase_rating_list=[]            for rec_item in recommend_list:                item_idx, item_sim=rec_item                prev_rating_list.append(self.rec.get_rating(item_idx, self.user_idx))                increase_rating_list.append(self.change_prediction_rating(item_idx, [rec_item], inc=True)[0])            if len(recommend_list)==0 : continue            print(prefer_item[0], '와(과) 유사합니다. : ', end='')            i=0            for rec_item in recommend_list:                item_idx, item_sim=rec_item                if i==0:                    print(self.idx_to_name[item_idx],                        '  유사도 : ', round(item_sim*100, 1), '%',                        '  예측 평점 변경 : ',prev_rating_list[i], '->', min(5, increase_rating_list[i]))                else:                    print(' '*31, self.idx_to_name[item_idx],                        '  유사도 : ', round(item_sim*100, 1), '%'                        '  예측 평점 변경 : ', prev_rating_list[i], '->', min(5, increase_rating_list[i]))                i+=1        self.rec.save_matrix('rating_matrix.np')